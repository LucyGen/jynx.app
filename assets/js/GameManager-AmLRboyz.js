import{g as t}from"./logger-CHTAPRDI.js";import{G as e,a as s,C as i,A as a}from"./sync-game-BdspoOK-.js";import{G as r,D as o}from"./config-RBrWeKVX.js";import"./analytics-service-UCL_K60g.js";import"./firebase-vendor-sIns1Pds.js";import"./vendor-CEMwkx1U.js";class n{constructor(t=e.SOLO){this.mode=t,this.state=s.MENU,this.score=0,this.highScore=0,this.perfectSyncs=0,this.combo=0,this.maxCombo=0,this.startTime=null,this.endTime=null}start(){this.state=s.PLAYING,this.score=0,this.perfectSyncs=0,this.combo=0,this.startTime=Date.now()}end(){this.state=s.GAME_OVER,this.endTime=Date.now()}addScore(t){this.score+=t,this.score>this.highScore&&(this.highScore=this.score)}incrementCombo(){this.combo++,this.combo>this.maxCombo&&(this.maxCombo=this.combo)}resetCombo(){this.combo=0}}class h{constructor(t,e){this.x=t,this.y=e}clone(){return new h(this.x,this.y)}distanceTo(t){const e=this.x-t.x,s=this.y-t.y;return Math.sqrt(e*e+s*s)}equals(t){return this.x===t.x&&this.y===t.y}}class c{constructor(t,e){this.x=t,this.y=e}clone(){return new c(this.x,this.y)}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.magnitude();return t>0?new c(this.x/t,this.y/t):new c(0,0)}}class l{constructor(t,e,s){this.playerId=t,this.position=e,this.velocity=new c(0,0),this.color=s,this.radius=i.DOT.RADIUS,this.isAlive=!0,this.isJumping=!1,this.isOnGround=!1}jump(){this.isOnGround&&this.isAlive&&(this.velocity.y=i.DOT.JUMP_VELOCITY,this.isJumping=!0,this.isOnGround=!1)}update(t){this.isAlive&&(this.position.x+=this.velocity.x*(t/16.67),this.position.y+=this.velocity.y*(t/16.67),this.velocity.y>0&&!this.isOnGround&&(this.isJumping=!1))}applyGravity(t){this.isAlive&&!this.isOnGround&&(this.velocity.y+=t,this.velocity.y>i.DOT.MAX_FALL_VELOCITY&&(this.velocity.y=i.DOT.MAX_FALL_VELOCITY))}setOnGround(t){this.position.y=t,this.velocity.y=0,this.isOnGround=!0,this.isJumping=!1}kill(){this.isAlive=!1,this.velocity.x=0,this.velocity.y=0}reset(t){this.position=t.clone(),this.velocity=new c(0,0),this.isAlive=!0,this.isJumping=!1,this.isOnGround=!1}getBounds(){return{x:this.position.x,y:this.position.y,radius:this.radius}}clone(){const t=new l(this.playerId,this.position.clone(),this.color);return t.velocity=this.velocity.clone(),t.isAlive=this.isAlive,t.isJumping=this.isJumping,t.isOnGround=this.isOnGround,t}}class u{constructor(){this.gravity=i.PHYSICS.GRAVITY,this.groundLevel=i.PHYSICS.GROUND_LEVEL}update(t,e){t.forEach((t=>{t.isAlive&&(t.applyGravity(this.gravity),t.update(e),t.position.y>=this.groundLevel*i.CANVAS.HEIGHT&&t.setOnGround(this.groundLevel*i.CANVAS.HEIGHT))}))}}class m{checkCircleRect(t,e){const s=Math.max(e.x,Math.min(t.x,e.x+e.width)),i=Math.max(e.y,Math.min(t.y,e.y+e.height)),a=t.x-s,r=t.y-i;return a*a+r*r<t.radius*t.radius}checkDotObstacle(t,e){if(!t.isAlive)return!1;const s=e.getBounds(),i=t.getBounds();return this.checkCircleRect(i,s.top)||this.checkCircleRect(i,s.bottom)}checkDotsSync(t,e,s){return!(!t.isAlive||!e.isAlive)&&Math.abs(t.position.y-e.position.y)<s}}class g{calculateObstacleScore(t,e){const s=t?i.SCORING.PERFECT_SYNC:i.SCORING.OBSTACLE_PASS,a=1+Math.min(e,10)*i.SCORING.COMBO_MULTIPLIER;return Math.floor(s*a)}checkPerfectSync(t,e){return Math.abs(t.position.y-e.position.y)<i.SCORING.SYNC_THRESHOLD}}const d=Object.freeze({SINGLE:"SINGLE",DOUBLE:"DOUBLE",MOVING:"MOVING",SPEED_BOOST:"SPEED_BOOST"});class S{constructor(t,e,s,a,r){this.position=new h(t,e),this.width=s,this.height=a,this.gap=r,this.speed=i.OBSTACLE.SPEED,this.passed=!1,this.scored=!1}update(t,e=1){this.position.x-=this.speed*e*(t/16.67)}isOffScreen(){return this.position.x+this.width<0}getBounds(){return{top:{x:this.position.x,y:0,width:this.width,height:this.position.y},bottom:{x:this.position.x,y:this.position.y+this.gap,width:this.width,height:this.height}}}}class p{constructor(t=null){this._seed=t||Date.now(),this._rng=this._createSeededRNG(this._seed),this._lastObstacleY=r.OBSTACLE.SPAWN_Y,this._obstacleCount=0,this._patternHistory=[],this._maxHistorySize=5}getNextObstacle(t,e){const s=o.getObstacleSpeed(t),i=this._generateObstacle(t,s);return this._obstacleCount++,this._updatePatternHistory(i.type),i}generate(t,e=1){const s=[],i=o.getObstacleSpeed(t);for(let a=0;a<e;a++){const e=this._generateObstacle(t,i);s.push(e),this._updatePatternHistory(e.type)}return s}generatePattern(t){const e=this._selectPattern(t),s=o.getObstacleSpeed(t),i=[];let a=r.OBSTACLE.SPAWN_Y;for(const r of e){const e=this._createObstacleByType(r,a,s,t);i.push(e),a-=this._calculateGap(t)}return i}shouldSpawn(t,e,s){return e-t>=o.getSpawnInterval(s)}reset(t=null){this._seed=t||Date.now(),this._rng=this._createSeededRNG(this._seed),this._lastObstacleY=r.OBSTACLE.SPAWN_Y,this._obstacleCount=0,this._patternHistory=[]}getSeed(){return this._seed}_generateObstacle(t,e){const s=this._selectObstacleType(t),i=this._calculateSpawnY(t);return this._createObstacleByType(s,i,e,t)}_selectObstacleType(t){const{OBSTACLE_TYPES:e,DIFFICULTY:s}=r,i=t>=s.ADVANCED_OBSTACLE_THRESHOLD;let a={[d.SINGLE]:e.SINGLE.probability,[d.DOUBLE]:e.DOUBLE.probability*(t/10),[d.MOVING]:i?e.MOVING.probability:0,[d.SPEED_BOOST]:i?e.SPEED_BOOST.probability:0};const o=Object.values(a).reduce(((t,e)=>t+e),0);Object.keys(a).forEach((t=>{a[t]/=o}));const n=this._patternHistory.slice(-3);if(3===n.length&&n.every((t=>t===n[0]))){a[n[0]]*=.3;const t=Object.values(a).reduce(((t,e)=>t+e),0);Object.keys(a).forEach((e=>{a[e]/=t}))}const h=this._rng();let c=0;for(const[r,l]of Object.entries(a))if(c+=l,h<=c)return r;return d.SINGLE}_createObstacleByType(t,e,s,i){switch(t){case d.SINGLE:return S.createSingle({y:e,lane:this._rng()>.5?"left":"right",speed:s});case d.DOUBLE:return S.createDouble({y:e,speed:s});case d.MOVING:return S.createMoving({y:e,speed:s,horizontalSpeed:r.OBSTACLE_TYPES.MOVING.horizontalSpeed});case d.SPEED_BOOST:return S.createSpeedBoost({y:e,lane:this._rng()>.5?"left":"right",speed:s*r.OBSTACLE_TYPES.SPEED_BOOST.speedMultiplier});default:return S.createSingle({y:e,lane:"left",speed:s})}}_calculateSpawnY(t){const e=this._calculateGap(t);return this._lastObstacleY-=e,this._lastObstacleY}_calculateGap(t){const{MIN_GAP:e,MAX_GAP:s}=r.OBSTACLE,i=e+(s-e)*(1-(t-1)/r.DIFFICULTY.LEVELS*.5),a=.2*i,o=i+(this._rng()*a*2-a);return Math.max(e,o)}_selectPattern(t){const e=this._getPatternsByDifficulty(t);return e[Math.floor(this._rng()*e.length)]}_getPatternsByDifficulty(t){const{SINGLE:e,DOUBLE:s,MOVING:i,SPEED_BOOST:a}=d,r=[[e],[e,e],[s],[e,e,e]],o=[[e,s],[s,e],[e,e,s],[i],[e,i]],n=[[s,i],[i,e,i],[a,e],[e,s,e],[i,s],[s,a,s]];return t<=3?r:t<=6?[...r,...o]:[...r,...o,...n]}_updatePatternHistory(t){this._patternHistory.push(t),this._patternHistory.length>this._maxHistorySize&&this._patternHistory.shift()}_createSeededRNG(t){let e=t;return function(){let t=e+=1831565813;return t=Math.imul(t^t>>>15,1|t),t^=t+Math.imul(t^t>>>7,61|t),((t^t>>>14)>>>0)/4294967296}}getStats(){return{seed:this._seed,obstaclesGenerated:this._obstacleCount,lastObstacleY:this._lastObstacleY,recentPattern:this._patternHistory.slice(-5)}}static createDailyChallenge(t=new Date){const e=1e4*t.getFullYear()+100*(t.getMonth()+1)+t.getDate();return new p(e)}static fromSeedString(t){let e=0;for(let s=0;s<t.length;s++)e=(e<<5)-e+t.charCodeAt(s),e|=0;return new p(Math.abs(e))}}class y{static instance=null;static getInstance(){return y.instance||(y.instance=new y),y.instance}constructor(){if(y.instance)throw new Error("GameManager is a singleton. Use GameManager.getInstance()");this.logger=t("GameManager"),this.gameState=null,this.currentMode=null,this.dots=[],this.obstacles=[],this.physicsEngine=null,this.collisionDetector=null,this.scoreCalculator=null,this.obstacleGenerator=null,this.inputManager=null,this.audioManager=null,this.uiManager=null,this.renderer=null,this.particleSystem=null,this.performanceMonitor=null,this.firebaseSync=null,this.analyticsService=null,this.isRunning=!1,this.isPaused=!1,this.gameLoopId=null,this.lastFrameTime=0,this.accumulator=0,this.currentDifficulty=1,this.gameTime=0,this.lastObstacleSpawnTime=0,this.frameCount=0,this.fpsBuffer=[],this.updateBudgetExceeded=0,this.eventListeners=new Map,this.lastSyncTime=0,this.comboActive=!1,this.logger.debug("GameManager constructed (singleton)")}async init(t){this.logger.info("Initializing GameManager"),this.canvas=t.canvas,this.inputManager=t.inputManager,this.audioManager=t.audioManager,this.uiManager=t.uiManager,this.renderer=t.renderer,this.particleSystem=t.particleSystem,this.performanceMonitor=t.performanceMonitor,this.firebaseSync=t.firebaseSync||null,this.analyticsService=t.analyticsService||null,this.physicsEngine=new u,this.collisionDetector=new m,this.scoreCalculator=new g,this.obstacleGenerator=new p,this.gameState=new n(e.SOLO),this.setupInputHandlers(),this.logger.info("GameManager initialized successfully")}setupInputHandlers(){this.inputManager&&this.inputManager.on("jump",(t=>{this.handleJumpInput(t)}))}handleJumpInput(t){if(this.gameState.state!==s.PLAYING)return;const{player:e,inputType:i,timestamp:o}=t,n=this.dots[e-1];n&&n.isAlive&&(n.jump(),this.audioManager&&this.audioManager.play(a.JUMP),this.emit("jump",{player:e,timestamp:o,dot:n}),2===this.dots.length)&&(o-this.lastSyncTime<r.SCORE.SYNC_THRESHOLD_MS&&this.handlePerfectSync(o),this.lastSyncTime=o)}handlePerfectSync(t){this.gameState.perfectSyncs++,this.gameState.incrementCombo();const e=r.SCORE.PERFECT_SYNC_BONUS;this.gameState.addScore(e),this.audioManager&&this.audioManager.play(a.SUCCESS),this.particleSystem&&this.dots.forEach((t=>{this.particleSystem.emit("SUCCESS",{x:t.position.x,y:t.position.y},10)})),this.emit("perfectSync",{timestamp:t,combo:this.gameState.combo}),this.logger.debug(`Perfect sync! Combo: ${this.gameState.combo}`)}async startSoloGame(){this.logger.info("Starting solo game"),this.currentMode=e.SOLO,this.gameState.mode=e.SOLO,await this.startGame(),this.analyticsService&&this.analyticsService.trackEvent("game_start",{mode:"solo"})}async startLocalDuoGame(){this.logger.info("Starting local duo game"),this.currentMode=e.DUO,this.gameState.mode=e.DUO,await this.startGame(),this.analyticsService&&this.analyticsService.trackEvent("game_start",{mode:"local_duo"})}async startOnlineDuoGame(t){if(this.logger.info(`Starting online duo game - Room: ${t}`),!this.firebaseSync)throw this.logger.error("Firebase sync not available"),new Error("Online mode requires Firebase integration");this.currentMode=e.ONLINE,this.gameState.mode=e.ONLINE,await this.firebaseSync.joinRoom(t),await this.startGame(),this.analyticsService&&this.analyticsService.trackEvent("game_start",{mode:"online_duo",roomId:t})}async startGame(){this.resetGameState(),this.initializeDots(),this.obstacles=[],this.lastObstacleSpawnTime=0,this.currentDifficulty=1,this.gameTime=0,this.frameCount=0,this.fpsBuffer=[],this.updateBudgetExceeded=0,this.gameState.start(),this.uiManager&&this.uiManager.showGameScreen(),this.startGameLoop(),this.emit("gameStart",{mode:this.currentMode,timestamp:Date.now()})}initializeDots(){const{DOT_LEFT_X:t,DOT_RIGHT_X:e,GROUND_Y:s}=r.DOT;this.dots=[new l(1,new h(r.DOT.LEFT_X,r.DOT.GROUND_Y),r.COLORS.DOT_LEFT),new l(2,new h(r.DOT.RIGHT_X,r.DOT.GROUND_Y),r.COLORS.DOT_RIGHT)],this.dots.forEach((t=>{t.isOnGround=!0}))}resetGameState(){this.gameState.score=0,this.gameState.perfectSyncs=0,this.gameState.combo=0,this.gameState.maxCombo=0,this.gameState.startTime=null,this.gameState.endTime=null,this.lastSyncTime=0,this.comboActive=!1}startGameLoop(){this.isRunning=!0,this.isPaused=!1,this.lastFrameTime=performance.now(),this.accumulator=0,this.logger.debug("Game loop started");const t=e=>{this.isRunning&&(this.gameLoop(e),this.gameLoopId=requestAnimationFrame(t))};this.gameLoopId=requestAnimationFrame(t)}gameLoop(t){const e=t-this.lastFrameTime,s=Math.min(e,i.GAME.MAX_DELTA_TIME)/1e3;if(this.lastFrameTime=t,this.performanceMonitor&&this.performanceMonitor.update(s),!this.isPaused){const t=performance.now();this.update(s);const e=performance.now()-t;e>i.PERFORMANCE.BUDGET_MS&&(this.updateBudgetExceeded++,i.PERFORMANCE.LOG_WARNINGS&&this.logger.warn(`Update exceeded budget: ${e.toFixed(2)}ms`))}this.render(s),this.trackFPS(s)}update(t){this.gameState.state===s.PLAYING&&(this.gameTime+=t,this.updatePhysics(t),this.updateObstacles(t),this.spawnObstacles(),this.checkCollisions(),this.updateScore(t),this.updateDifficulty(),this.updateCombo(t),this.currentMode===e.ONLINE&&this.firebaseSync&&this.syncNetworkState(),this.particleSystem&&this.particleSystem.update(t),this.cleanupObstacles())}updatePhysics(t){this.physicsEngine.update(this.dots,t)}updateObstacles(t){const e=o.getObstacleSpeed(this.currentDifficulty);this.obstacles.forEach((s=>{s.position.y+=e*t}))}spawnObstacles(){const t=1e3*this.gameTime;if(this.obstacleGenerator.shouldSpawn(this.lastObstacleSpawnTime,t,this.currentDifficulty)){const e=this.obstacleGenerator.getNextObstacle(this.currentDifficulty,t);e&&(this.obstacles.push(e),this.lastObstacleSpawnTime=t)}}checkCollisions(){this.dots.forEach((t=>{t.isAlive&&this.obstacles.forEach((e=>{this.collisionDetector.checkDotObstacle(t,e)&&this.handleCollision(t,e)}))})),this.dots.some((t=>t.isAlive))||this.gameOver()}handleCollision(t,e){t.kill(),this.audioManager&&this.audioManager.play(a.COLLISION),this.particleSystem&&this.particleSystem.emit("EXPLOSION",{x:t.position.x,y:t.position.y},20),this.renderer&&this.renderer.triggerScreenShake&&this.renderer.triggerScreenShake(),this.gameState.resetCombo(),this.emit("collision",{dot:t,obstacle:e,timestamp:Date.now()}),this.logger.debug(`Collision: Dot ${t.playerId} hit obstacle`)}updateScore(t){const e=r.SCORE.BASE_POINTS_PER_SECOND*t;this.gameState.addScore(Math.floor(e)),this.obstacles.forEach((t=>{if(!t.scored&&t.position.y>r.DOT.GROUND_Y){t.scored=!0;const e=r.SCORE.OBSTACLE_DODGE_BONUS;this.gameState.addScore(e),this.gameState.score%500==0&&this.emit("scoreMilestone",{score:this.gameState.score})}}))}updateDifficulty(){const t=Math.min(r.DIFFICULTY.LEVELS,Math.floor(1e3*this.gameTime/r.DIFFICULTY.TIME_PER_LEVEL)+1);t!==this.currentDifficulty&&(this.currentDifficulty=t,this.emit("difficultyChange",{difficulty:t}),this.logger.info(`Difficulty increased to ${t}`))}updateCombo(t){this.gameState.combo>0&&performance.now()-this.lastSyncTime>r.SCORE.COMBO_DECAY_TIME&&(this.gameState.resetCombo(),this.emit("comboLost",{maxCombo:this.gameState.maxCombo}))}syncNetworkState(){if(!this.firebaseSync)return;const t={dots:this.dots.map((t=>({playerId:t.playerId,x:t.position.x,y:t.position.y,vx:t.velocity.x,vy:t.velocity.y,isAlive:t.isAlive}))),obstacles:this.obstacles.map((t=>({x:t.position.x,y:t.position.y,type:t.type}))),score:this.gameState.score,difficulty:this.currentDifficulty,timestamp:Date.now()};this.firebaseSync.syncState(t)}cleanupObstacles(){const t=r.CANVAS.HEIGHT;this.obstacles=this.obstacles.filter((e=>e.position.y<t+100))}render(t){if(!this.renderer)return;const e={state:this.gameState.state,score:this.gameState.score,combo:this.gameState.combo,difficulty:this.currentDifficulty,time:this.gameTime,syncScore:this.calculateSyncScore(),dots:this.dots.map((t=>({id:`dot${t.playerId}`,x:t.position.x,y:t.position.y,radius:t.radius,color:t.color===r.COLORS.DOT_LEFT?"PRIMARY_DOT":"SECONDARY_DOT",vx:t.velocity.x,vy:t.velocity.y,squashStretch:this.calculateSquashStretch(t),isAlive:t.isAlive}))),obstacles:this.obstacles.map((t=>({x:t.position.x,y:t.position.y,width:t.width||40,height:t.height||20,type:t.type||"standard"})))};this.renderer.render(e,t),this.particleSystem&&(this.performanceMonitor?.getQualitySettings()||{maxParticles:50}).maxParticles>0&&this.particleSystem.render(this.renderer.backCtx,this.renderer.scale||1,this.renderer.pixelRatio||1)}calculateSyncScore(){if(2!==this.dots.length)return 0;const[t,e]=this.dots,s=Math.abs(t.position.y-e.position.y),i=r.CANVAS.HEIGHT/2;return Math.max(0,Math.min(100,100-s/i*100))}calculateSquashStretch(t){return 1+Math.abs(t.velocity.y)/400*.3}trackFPS(t){this.frameCount++;const e=1/t;this.fpsBuffer.push(e),this.fpsBuffer.length>60&&this.fpsBuffer.shift(),this.performanceMonitor&&i.PERFORMANCE.ENABLED&&this.fpsBuffer.reduce(((t,e)=>t+e),0)/this.fpsBuffer.length<55&&this.particleSystem&&this.logger.warn("Low FPS detected, reducing particle quality")}pause(){this.gameState.state===s.PLAYING&&(this.isPaused=!0,this.gameState.state=s.PAUSED,this.uiManager&&this.uiManager.showPauseMenu(),this.emit("pause",{timestamp:Date.now()}),this.logger.info("Game paused"))}resume(){this.gameState.state===s.PAUSED&&(this.isPaused=!1,this.gameState.state=s.PLAYING,this.lastFrameTime=performance.now(),this.uiManager&&this.uiManager.hideUI(),this.emit("resume",{timestamp:Date.now()}),this.logger.info("Game resumed"))}async restart(){switch(this.logger.info("Restarting game"),this.stop(),this.currentMode){case e.SOLO:await this.startSoloGame();break;case e.DUO:await this.startLocalDuoGame();break;case e.ONLINE:this.logger.warn("Online restart not implemented - returning to menu");break;default:await this.startSoloGame()}}gameOver(){if(this.gameState.state===s.GAME_OVER)return;this.logger.info(`Game over - Score: ${this.gameState.score}`),this.gameState.end(),this.stop(),this.audioManager&&this.audioManager.play(a.DEATH);const t=this.gameState.score>this.gameState.highScore;t&&(this.gameState.highScore=this.gameState.score,this.emit("newHighScore",{score:this.gameState.score}));const e=this.gameState.endTime-this.gameState.startTime;this.uiManager&&this.uiManager.showGameOverScreen({score:this.gameState.score,highScore:this.gameState.highScore,perfectSyncs:this.gameState.perfectSyncs,maxCombo:this.gameState.maxCombo,duration:e,isHighScore:t}),this.analyticsService&&this.analyticsService.trackEvent("game_over",{mode:this.currentMode,score:this.gameState.score,duration:e,perfectSyncs:this.gameState.perfectSyncs,difficulty:this.currentDifficulty}),this.emit("gameOver",{score:this.gameState.score,duration:e,perfectSyncs:this.gameState.perfectSyncs,isHighScore:t})}stop(){this.isRunning=!1,this.gameLoopId&&(cancelAnimationFrame(this.gameLoopId),this.gameLoopId=null),this.logger.debug("Game loop stopped")}destroy(){this.logger.info("Destroying GameManager"),this.stop(),this.dots=[],this.obstacles=[],this.eventListeners.clear(),this.gameState=null,this.currentMode=null,this.logger.debug("GameManager destroyed")}on(t,e){this.eventListeners.has(t)||this.eventListeners.set(t,[]),this.eventListeners.get(t).push(e)}off(t,e){if(!this.eventListeners.has(t))return;const s=this.eventListeners.get(t),i=s.indexOf(e);i>-1&&s.splice(i,1)}emit(t,e){this.eventListeners.has(t)&&this.eventListeners.get(t).forEach((s=>{try{s(e)}catch(i){this.logger.error(`Error in event handler for '${t}':`,i)}}))}getStats(){return{state:this.gameState.state,mode:this.currentMode,score:this.gameState.score,highScore:this.gameState.highScore,perfectSyncs:this.gameState.perfectSyncs,combo:this.gameState.combo,maxCombo:this.gameState.maxCombo,difficulty:this.currentDifficulty,gameTime:this.gameTime,fps:this.fpsBuffer.length>0?Math.round(this.fpsBuffer.reduce(((t,e)=>t+e),0)/this.fpsBuffer.length):0,updateBudgetExceeded:this.updateBudgetExceeded,obstacleCount:this.obstacles.length}}getPerformanceMetrics(){const t=this.fpsBuffer.length>0?this.fpsBuffer.reduce(((t,e)=>t+e),0)/this.fpsBuffer.length:0;return{fps:{current:this.fpsBuffer[this.fpsBuffer.length-1]||0,average:t,min:Math.min(...this.fpsBuffer),max:Math.max(...this.fpsBuffer)},updateBudgetExceeded:this.updateBudgetExceeded,frameCount:this.frameCount,entityCount:this.dots.length+this.obstacles.length}}setDependency(t,e){this[t]=e,this.logger.debug(`Dependency injected: ${t}`)}}export{y as default};
